import type {
  ParsedSpec,
  GeneratedFile,
  GenerateOptions,
  FieldSpec,
  EndpointSpec,
  CrudAction,
} from "@specforge-dev/core";
import type { SpecForgePlugin } from "../types.js";

function mapFieldToJsonSchemaType(field: FieldSpec): { type: string; format?: string; enum?: string[] } {
  switch (field.type) {
    case "uuid":
      return { type: "string", format: "uuid" };
    case "string":
      return { type: "string" };
    case "text":
      return { type: "string" };
    case "integer":
      return { type: "integer" };
    case "float":
      return { type: "number", format: "float" };
    case "boolean":
      return { type: "boolean" };
    case "datetime":
      return { type: "string", format: "date-time" };
    case "date":
      return { type: "string", format: "date" };
    case "json":
      return { type: "object" };
    case "enum":
      return { type: "string", enum: field.values };
    case "relation":
      return { type: "string", format: "uuid" };
    default:
      return { type: "string" };
  }
}

function generateOpenApiSpec(spec: ParsedSpec): string {
  const openapi: Record<string, unknown> = {
    openapi: "3.0.3",
    info: {
      title: `${spec.name} API`,
      version: spec.version,
      description: `API specification for ${spec.name}, generated by SpecForge.`,
    },
    servers: [
      {
        url: `http://localhost:3000${spec.api.basePath}`,
        description: "Local development",
      },
    ],
    paths: {} as Record<string, unknown>,
    components: {
      schemas: {} as Record<string, unknown>,
    },
  };

  const paths = openapi.paths as Record<string, Record<string, unknown>>;
  const schemas = (openapi.components as Record<string, unknown>).schemas as Record<string, unknown>;

  // Generate schemas for each model
  for (const [modelName, modelSpec] of Object.entries(spec.models)) {
    const properties: Record<string, unknown> = {};
    const required: string[] = [];

    for (const [fieldName, fieldSpec] of Object.entries(modelSpec.fields)) {
      const schema = mapFieldToJsonSchemaType(fieldSpec);
      properties[fieldName] = schema;

      if (!fieldSpec.nullable && !fieldSpec.auto && fieldSpec.default === undefined) {
        required.push(fieldName);
      }
    }

    schemas[modelName] = {
      type: "object",
      properties,
      ...(required.length > 0 ? { required } : {}),
    };

    // Create input schema (without auto/primary fields)
    const inputProperties: Record<string, unknown> = {};
    const inputRequired: string[] = [];
    for (const [fieldName, fieldSpec] of Object.entries(modelSpec.fields)) {
      if (fieldSpec.auto || fieldSpec.primary) continue;
      inputProperties[fieldName] = mapFieldToJsonSchemaType(fieldSpec);
      if (!fieldSpec.nullable && fieldSpec.default === undefined) {
        inputRequired.push(fieldName);
      }
    }

    schemas[`Create${modelName}Input`] = {
      type: "object",
      properties: inputProperties,
      ...(inputRequired.length > 0 ? { required: inputRequired } : {}),
    };
  }

  // Generate paths for each endpoint
  for (const endpoint of spec.api.endpoints) {
    const modelName = endpoint.model;

    if (endpoint.actions.includes("list") || endpoint.actions.includes("create")) {
      const pathOps: Record<string, unknown> = {};

      if (endpoint.actions.includes("list")) {
        pathOps.get = {
          summary: `List all ${modelName}s`,
          operationId: `list${modelName}s`,
          tags: [modelName],
          responses: {
            "200": {
              description: "Successful response",
              content: {
                "application/json": {
                  schema: {
                    type: "object",
                    properties: {
                      data: {
                        type: "array",
                        items: { $ref: `#/components/schemas/${modelName}` },
                      },
                    },
                  },
                },
              },
            },
          },
        };
      }

      if (endpoint.actions.includes("create")) {
        pathOps.post = {
          summary: `Create a new ${modelName}`,
          operationId: `create${modelName}`,
          tags: [modelName],
          requestBody: {
            required: true,
            content: {
              "application/json": {
                schema: {
                  $ref: `#/components/schemas/Create${modelName}Input`,
                },
              },
            },
          },
          responses: {
            "201": {
              description: "Created successfully",
              content: {
                "application/json": {
                  schema: {
                    type: "object",
                    properties: {
                      data: { $ref: `#/components/schemas/${modelName}` },
                    },
                  },
                },
              },
            },
          },
        };
      }

      paths[endpoint.path] = pathOps;
    }

    // Single-item routes
    const singleActions = endpoint.actions.filter((a) =>
      ["get", "update", "delete"].includes(a)
    );
    if (singleActions.length > 0) {
      const singlePathOps: Record<string, unknown> = {};
      const pathWithId = `${endpoint.path}/{id}`;

      const idParam = {
        name: "id",
        in: "path",
        required: true,
        schema: { type: "string", format: "uuid" },
      };

      if (endpoint.actions.includes("get")) {
        singlePathOps.get = {
          summary: `Get ${modelName} by ID`,
          operationId: `get${modelName}`,
          tags: [modelName],
          parameters: [idParam],
          responses: {
            "200": {
              description: "Successful response",
              content: {
                "application/json": {
                  schema: {
                    type: "object",
                    properties: {
                      data: { $ref: `#/components/schemas/${modelName}` },
                    },
                  },
                },
              },
            },
            "404": { description: "Not found" },
          },
        };
      }

      if (endpoint.actions.includes("update")) {
        singlePathOps.put = {
          summary: `Update ${modelName}`,
          operationId: `update${modelName}`,
          tags: [modelName],
          parameters: [idParam],
          requestBody: {
            required: true,
            content: {
              "application/json": {
                schema: {
                  $ref: `#/components/schemas/Create${modelName}Input`,
                },
              },
            },
          },
          responses: {
            "200": {
              description: "Updated successfully",
              content: {
                "application/json": {
                  schema: {
                    type: "object",
                    properties: {
                      data: { $ref: `#/components/schemas/${modelName}` },
                    },
                  },
                },
              },
            },
            "404": { description: "Not found" },
          },
        };
      }

      if (endpoint.actions.includes("delete")) {
        singlePathOps.delete = {
          summary: `Delete ${modelName}`,
          operationId: `delete${modelName}`,
          tags: [modelName],
          parameters: [idParam],
          responses: {
            "204": { description: "Deleted successfully" },
            "404": { description: "Not found" },
          },
        };
      }

      paths[pathWithId] = singlePathOps;
    }
  }

  return JSON.stringify(openapi, null, 2);
}

function generateErDiagram(spec: ParsedSpec): string {
  let md = `# ER Diagram\n\n`;
  md += `> Generated by SpecForge from ${spec.name} v${spec.version}\n\n`;
  md += "```mermaid\nerDiagram\n";

  for (const [modelName, modelSpec] of Object.entries(spec.models)) {
    md += `    ${modelName} {\n`;
    for (const [fieldName, fieldSpec] of Object.entries(modelSpec.fields)) {
      if (fieldSpec.type === "relation") continue;
      const mermaidType = fieldSpec.type === "uuid" ? "string" : fieldSpec.type;
      const pk = fieldSpec.primary ? " PK" : "";
      const uk = fieldSpec.unique ? " UK" : "";
      md += `        ${mermaidType} ${fieldName}${pk}${uk}\n`;
    }
    md += `    }\n`;
  }

  // Add relationships
  for (const [modelName, modelSpec] of Object.entries(spec.models)) {
    for (const [fieldName, fieldSpec] of Object.entries(modelSpec.fields)) {
      if (fieldSpec.type !== "relation" || !fieldSpec.model) continue;

      const relSymbol =
        fieldSpec.kind === "one-to-many"
          ? "||--o{"
          : fieldSpec.kind === "many-to-one"
            ? "}o--||"
            : fieldSpec.kind === "many-to-many"
              ? "}o--o{"
              : "||--||";

      md += `    ${modelName} ${relSymbol} ${fieldSpec.model} : "${fieldName}"\n`;
    }
  }

  md += "```\n";
  return md;
}

function generateApiReadme(spec: ParsedSpec): string {
  let md = `# API Documentation\n\n`;
  md += `> ${spec.name} v${spec.version} — Generated by SpecForge\n\n`;
  md += `## Base URL\n\n`;
  md += `\`\`\`\n${spec.api.basePath}\n\`\`\`\n\n`;

  if (spec.api.auth) {
    md += `## Authentication\n\n`;
    md += `Strategy: **${spec.api.auth.strategy}**\n\n`;
  }

  md += `## Endpoints\n\n`;

  for (const endpoint of spec.api.endpoints) {
    md += `### ${endpoint.model}\n\n`;
    md += `Base path: \`${endpoint.path}\`\n\n`;
    md += `| Method | Path | Action | Auth |\n`;
    md += `|--------|------|--------|------|\n`;

    const actionMethods: Record<CrudAction, { method: string; suffix: string }> = {
      list: { method: "GET", suffix: "" },
      get: { method: "GET", suffix: "/:id" },
      create: { method: "POST", suffix: "" },
      update: { method: "PUT", suffix: "/:id" },
      delete: { method: "DELETE", suffix: "/:id" },
    };

    for (const action of endpoint.actions) {
      const { method, suffix } = actionMethods[action];
      const auth = endpoint.auth?.[action] ?? "—";
      md += `| ${method} | \`${endpoint.path}${suffix}\` | ${action} | ${auth} |\n`;
    }

    md += `\n`;
  }

  md += `## Models\n\n`;

  for (const [modelName, modelSpec] of Object.entries(spec.models)) {
    md += `### ${modelName}\n\n`;
    md += `| Field | Type | Constraints |\n`;
    md += `|-------|------|-------------|\n`;

    for (const [fieldName, fieldSpec] of Object.entries(modelSpec.fields)) {
      const constraints: string[] = [];
      if (fieldSpec.primary) constraints.push("PRIMARY KEY");
      if (fieldSpec.unique) constraints.push("UNIQUE");
      if (fieldSpec.nullable) constraints.push("NULLABLE");
      if (fieldSpec.auto) constraints.push("AUTO");
      if (fieldSpec.type === "enum" && fieldSpec.values) {
        constraints.push(`enum(${fieldSpec.values.join(", ")})`);
      }
      if (fieldSpec.type === "relation" && fieldSpec.model) {
        constraints.push(`→ ${fieldSpec.model} (${fieldSpec.kind ?? "one-to-one"})`);
      }

      md += `| ${fieldName} | ${fieldSpec.type} | ${constraints.join(", ") || "—"} |\n`;
    }

    md += `\n`;
  }

  return md;
}

export const docsPlugin: SpecForgePlugin = {
  name: "docs",
  version: "0.1.0",

  generate(spec: ParsedSpec, options: GenerateOptions): GeneratedFile[] {
    const files: GeneratedFile[] = [];

    // OpenAPI spec
    files.push({
      path: "docs/openapi.json",
      content: generateOpenApiSpec(spec),
      overwrite: true,
    });

    // Mermaid ER diagram
    files.push({
      path: "docs/er-diagram.md",
      content: generateErDiagram(spec),
      overwrite: true,
    });

    // API README
    files.push({
      path: "docs/API.md",
      content: generateApiReadme(spec),
      overwrite: true,
    });

    return files;
  },
};
