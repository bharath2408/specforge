import type {
  ParsedSpec,
  GeneratedFile,
  GenerateOptions,
} from "@specforge-dev/core";
import type { SpecForgePlugin } from "../types.js";

function generateAuthMiddleware(spec: ParsedSpec): string {
  const strategy = spec.api.auth?.strategy ?? "jwt";

  return `// Generated by SpecForge — do not edit manually
// Authentication middleware (${strategy})

import type { FastifyRequest, FastifyReply } from "fastify";

export interface AuthUser {
  id: string;
  role: "public" | "authenticated" | "admin" | "owner";
}

declare module "fastify" {
  interface FastifyRequest {
    user?: AuthUser;
  }
}

/**
 * JWT authentication guard.
 * Verifies the Authorization header and attaches user to request.
 */
export async function authGuard(
  request: FastifyRequest,
  reply: FastifyReply
): Promise<void> {
  const authHeader = request.headers.authorization;

  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    reply.status(401).send({
      error: "Unauthorized",
      message: "Missing or invalid Authorization header",
    });
    return;
  }

  const token = authHeader.substring(7);

  try {
    // TODO: Implement actual ${strategy} token verification
    // const payload = await verifyToken(token);
    const payload = { id: "user-id", role: "authenticated" as const };

    request.user = {
      id: payload.id,
      role: payload.role,
    };
  } catch (err) {
    reply.status(401).send({
      error: "Unauthorized",
      message: "Invalid or expired token",
    });
  }
}

/**
 * Role-based access control middleware.
 * Checks if the authenticated user has the required role.
 */
export function requireRole(...roles: AuthUser["role"][]) {
  return async (request: FastifyRequest, reply: FastifyReply): Promise<void> => {
    if (!request.user) {
      reply.status(401).send({
        error: "Unauthorized",
        message: "Authentication required",
      });
      return;
    }

    if (!roles.includes(request.user.role)) {
      reply.status(403).send({
        error: "Forbidden",
        message: \`Requires one of: \${roles.join(", ")}\`,
      });
    }
  };
}

/**
 * Owner-only access control.
 * Checks if the authenticated user owns the resource.
 */
export function requireOwner(getOwnerId: (request: FastifyRequest) => string | Promise<string>) {
  return async (request: FastifyRequest, reply: FastifyReply): Promise<void> => {
    if (!request.user) {
      reply.status(401).send({
        error: "Unauthorized",
        message: "Authentication required",
      });
      return;
    }

    if (request.user.role === "admin") return;

    const ownerId = await getOwnerId(request);
    if (request.user.id !== ownerId) {
      reply.status(403).send({
        error: "Forbidden",
        message: "You do not own this resource",
      });
    }
  };
}
`;
}

function generateValidationMiddleware(spec: ParsedSpec): string {
  const endpoints = spec.api.endpoints;

  let code = `// Generated by SpecForge — do not edit manually
// Request validation middleware

import type { FastifyRequest, FastifyReply } from "fastify";

export interface ValidationError {
  field: string;
  message: string;
}

export interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
}

/**
 * Validate request body against a schema definition.
 */
export function validateBody(schema: Record<string, FieldValidator>) {
  return async (request: FastifyRequest, reply: FastifyReply): Promise<void> => {
    const body = request.body as Record<string, unknown> | undefined;
    if (!body || typeof body !== "object") {
      reply.status(400).send({
        error: "Bad Request",
        message: "Request body is required",
      });
      return;
    }

    const errors: ValidationError[] = [];

    for (const [field, validator] of Object.entries(schema)) {
      const value = body[field];

      if (validator.required && (value === undefined || value === null)) {
        errors.push({ field, message: \`\${field} is required\` });
        continue;
      }

      if (value === undefined || value === null) continue;

      if (validator.type === "string" && typeof value !== "string") {
        errors.push({ field, message: \`\${field} must be a string\` });
      }

      if (validator.type === "number" && typeof value !== "number") {
        errors.push({ field, message: \`\${field} must be a number\` });
      }

      if (validator.type === "boolean" && typeof value !== "boolean") {
        errors.push({ field, message: \`\${field} must be a boolean\` });
      }

      if (validator.min !== undefined && typeof value === "number" && value < validator.min) {
        errors.push({ field, message: \`\${field} must be at least \${validator.min}\` });
      }

      if (validator.max !== undefined && typeof value === "number" && value > validator.max) {
        errors.push({ field, message: \`\${field} must be at most \${validator.max}\` });
      }

      if (validator.values && typeof value === "string" && !validator.values.includes(value)) {
        errors.push({ field, message: \`\${field} must be one of: \${validator.values.join(", ")}\` });
      }
    }

    if (errors.length > 0) {
      reply.status(400).send({
        error: "Validation Error",
        message: "Request body validation failed",
        details: errors,
      });
    }
  };
}

export interface FieldValidator {
  type: "string" | "number" | "boolean" | "object";
  required?: boolean;
  min?: number;
  max?: number;
  values?: string[];
}

/**
 * Validate request params contain a valid UUID id.
 */
export async function validateIdParam(
  request: FastifyRequest,
  reply: FastifyReply
): Promise<void> {
  const params = request.params as Record<string, string>;
  const id = params.id;

  if (!id) {
    reply.status(400).send({
      error: "Bad Request",
      message: "ID parameter is required",
    });
    return;
  }

  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  if (!uuidRegex.test(id)) {
    reply.status(400).send({
      error: "Bad Request",
      message: "ID must be a valid UUID",
    });
  }
}
`;

  return code;
}

function generateErrorHandler(): string {
  return `// Generated by SpecForge — do not edit manually
// Global error handler middleware

import type { FastifyError, FastifyRequest, FastifyReply } from "fastify";

export interface ErrorResponse {
  error: string;
  message: string;
  statusCode: number;
  details?: unknown;
}

/**
 * Global error handler for Fastify.
 * Normalizes all errors into a consistent JSON response format.
 */
export function errorHandler(
  error: FastifyError,
  request: FastifyRequest,
  reply: FastifyReply
): void {
  const statusCode = error.statusCode ?? 500;

  const response: ErrorResponse = {
    error: getErrorName(statusCode),
    message: statusCode >= 500 ? "Internal Server Error" : error.message,
    statusCode,
  };

  // Include validation details for 400 errors
  if (statusCode === 400 && error.validation) {
    response.details = error.validation;
  }

  // Log server errors
  if (statusCode >= 500) {
    request.log.error(error);
  }

  reply.status(statusCode).send(response);
}

function getErrorName(statusCode: number): string {
  const names: Record<number, string> = {
    400: "Bad Request",
    401: "Unauthorized",
    403: "Forbidden",
    404: "Not Found",
    409: "Conflict",
    422: "Unprocessable Entity",
    429: "Too Many Requests",
    500: "Internal Server Error",
    502: "Bad Gateway",
    503: "Service Unavailable",
  };
  return names[statusCode] ?? "Error";
}

/**
 * Not found handler for unmatched routes.
 */
export function notFoundHandler(
  request: FastifyRequest,
  reply: FastifyReply
): void {
  reply.status(404).send({
    error: "Not Found",
    message: \`Route \${request.method} \${request.url} not found\`,
    statusCode: 404,
  });
}
`;
}

export const middlewarePlugin: SpecForgePlugin = {
  name: "middleware",
  version: "0.1.0",

  generate(spec: ParsedSpec, options: GenerateOptions): GeneratedFile[] {
    const files: GeneratedFile[] = [];

    // Auth middleware
    files.push({
      path: "src/middleware/auth.ts",
      content: generateAuthMiddleware(spec),
      overwrite: true,
    });

    // Validation middleware
    files.push({
      path: "src/middleware/validation.ts",
      content: generateValidationMiddleware(spec),
      overwrite: true,
    });

    // Error handler
    files.push({
      path: "src/middleware/error-handler.ts",
      content: generateErrorHandler(),
      overwrite: true,
    });

    return files;
  },
};
